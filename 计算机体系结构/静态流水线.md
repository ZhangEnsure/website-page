# 静态流水线

最常规的指令执行可以视为三个操作：计算pc、取指、执行。如果我们有 n 条指令，不考虑任何的流水线操作，那就需要 3n 个时钟周期 cpu 才能完成 n 条指令的运算。
1. 第一个时钟：把 npc 的值送入 pc 中。
2. 第二个时钟：把取出的指令送到 IR 中，并将相关的
3. 第三个时钟：把指令的运算结果送入寄存器或者内存中。

> 改进1: 我们把第 n+1 条指令的计算 pc 与第 n 条指令的执行并行

如此说来，我们把原来的 3 个时钟改进为 2 个时钟就可以了。

> 改进2: 我们在改进1的基础上，能否把第 n+1 条指令的取指与第 n 条指令的执行并行？

在“取指”的过程中，我们还需要获取运算所需的寄存器的值。本条指令的取指过程进行时，上一条指令可能已经完成了写回的过程，所以理论上改进2是可以进行的。不过，如果上一条指令是转移指令，下一条指令的取指取决于转移指令的成功与否，往哪里跳转？所以这两条指令并不能重叠，需要在两者之间插入一条延迟槽指令。经过上述两种改进，整个CPU的所有指令流水线只需要一个时钟周期就可以了。

> 改进3: 划分指令的执行阶段

但是，考虑到指令的执行过程比较复杂，仅仅把问题考虑的这么简单是不理想的。我们把指令的“整体执行过程”划分为 5 个阶段，按照划分的阶段再细致的考虑流水线的问题。
1. 取指 IF.
2. 译码 ID.译码阶段可能会读取寄存器的值、送到运算单元运算。
3. 执行 EXE.执行的结果可能是我们下一步要访存的地址，或者是准备写回的结果等等。
4. 访存 MEM.
5. 写回 WB.

经过上述划分阶段之后，我们还需要在每一个 cpu 执行阶段增加几组寄存器，存储每一个阶段的结果还有其后续流水线所需要的控制信号、目标寄存器号等等信息。

## 指令相关

指令相关可以分为 3 种，分别是数据相关、结构相关和控制相关。
1. 数据相关。这种相关比较好判断，常见的有①写后读相关
(Read After Write，RAW)，就是后面指令要用到前面指令所写的数据，这是最常见的类型，也称为真相关，②写后写相关(Write After. Write， WAW)，也称为输出相关，即两条指令写同一个单元，在乱序执行的结构中如果后面的指令先写，前面的指令后写，就会产生错误的结果;③读后写相关( Write After Read， WAR)，在乱序执行的结构或者读写指令流水级不一样时，如果后面的写指令执行得快，在前面的读指令读数之前就把目标单元原来的值覆盖掉了，导致读数指令读到了该单元“未来”的值，从而引起错误。
2. 